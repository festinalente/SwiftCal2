function SwiftCal () {
  const disabled = false;
  // things we use:
  const datesSelectedArrayObjects = [];
  // dates chosen by end user (if any)
  const endUserSelection = [];
  // simply tracks the above array:
  const endUserSelectionTrackingArray = [];
  // strings; easier to compare:
  const datesSelectedArray = [];
  let selectRange;
  let singleDateChoice;
  let lastDateClicked;
  let calendar;
  let timeChooserModal;
  let saveAction;
  let timeChooser;
  let clickCount = 1;
  let displayTimeG = false;
  let inst = 0;
  const times = {
    indexes: [],
    values: []
  };
  const time = {};

  this.calendar = function makeCalendar (
    parentDiv,
    preloadedDates,
    numberOfMonthsToDisplay,
    displayTime,
    endUser,
    endUserDurationChoice,
    backend,
    displayBlocked,
    datesOpen) {

    import { attach } from './domFunctions.js';
    import { blockDaysNotOpen } from './domFunctions.js';
    import { toggleDuration } from './domFunctions.js';
    import { timeChooser } from "./domGenerator";

    // Creates the calendar element
    calendar = document.createElement('div');
    // Calendar is defined globally within the constructor
    const calendarUniqueId = rand();
    // Checks whether the parent element is passed directecly, or its queryselector
    if (typeof parentDiv === 'string') {
      document.querySelector(parentDiv).appendChild(calendar);
    } else {
      parentDiv.appendChild(calendar);
    }

    calendar.id = `calendar${calendarUniqueId}`;
    calendar.classList.add('calendar');
    // Select range is a boolean
    selectRange = !!displayBlocked;

    if (displayTime === true) {
      displayTimeG = true;
      makeTimeElements(calendar);
    }
    /**
     * Writes the client's date duration to the endUserSelection array
     *
     * @param {string} durationInputId - The ID of the duration input element.
     * @param {number} duration - The duration value entered by the client.
     * @return {void} This function does not return a value.
     */
    function saveClientDateDuration() {
      const durationInputId = `durationInput${calendarUniqueId}`;
      const duration = document.getElementById(durationInputId).value;
      endUserSelection[endUserSelection.length - 1].duration = duration;
    }

    /**
     * Converts an array of dates into a new array of objects with formatted dates.
     *
     * @param {Array} dates - The array of dates.
     * @return {Promise} A promise that resolves to the new array of objects.
     */
    function convertDates (dates) {
      const promise = new Promise((resolve, reject) => {
        for (let i = 0; i < dates.length; i++) {
          if (dates[i].day) {
            datesSelectedArrayObjects.push(dates[i]);
            continue;
          }

          datesSelectedArrayObjects.push({ day: formatDateForCalendar(dates[i]) });
        }
      });
      return promise;
    }

    /**
     * Asynchronously preloads dates for the calendar.
     *
     * @param {object} caledar - the calendar object
     * @param {array} dates - an array of dates to preload
     * @return {void} 
     */
    async function preloadDatesFn (caledar, dates) {
      await convertDates(dates);
      for (let i = 0; i < datesSelectedArrayObjects.length; i++) {
        const dateNode = caledar.querySelector(`#${datesSelectedArrayObjects[i]}`);
        if (dateNode) {
          datesSelectedArray.push(dates[i].day);
          dateNode.style.backgroundColor = '#fc3';
          dateNode.classList.add('available');
        }
        if (endUser) {
          attach(dateNode);
          timeChooser();
        }
        if (displayTimeG) {
          generateTimesOnly(datesSelectedArrayObjects[i].times, dateNode);
        }
        if (selectRange && dateNode && !dateNode.classList.contains('filler')) {
          // use preloaded dates directly blocked.push(preloadedDates[i].day);
          dateNode.style.backgroundColor = '#333';
          dateNode.classList.add('blocked');
          dateNode.title = 'No availability on this day';
          const soldOut = document.createElement('p');
          soldOut.classList.add('calendarTime');
          soldOut.textContent = 'Sold out';
          dateNode.appendChild(soldOut);
        }
      }
    }
/*
    //afterCalendarInit CALL swiftCal() range before instantiating the caledar
    function preloadDatesFn(calendar, dates) {
      if (dates) {

        dates.forEach((date,i)=>{
          //date not passed correctly, convert:
          if(!date.day){
            dates[i] = {day : formatDateForCalendar(date)};
          }
        });
        //Assign dates to datesSelectedArrayObjects.
        datesSelectedArrayObjects = dates;
        for (var i = 0; i <= dates.length - 1; i++) {
          //Hacky way to get the id with an interger as a first character:
          var dateId = "[id='" + dates[i].day + "']";
          //Make sure element exists in the calendar
          //Query selector is used to search a specified calendar and not the dom in general:
          if (calendar.querySelector(dateId) !== null) {
            //Fill the tracking array:
            datesSelectedArray.push(dates[i].day);
            calendar.querySelector(dateId).style.backgroundColor = '#fc3';
            calendar.querySelector(dateId).classList.add('available');

            //endUser option with durations!
            if (endUser === true) {
              attach(calendar.querySelector(dateId));
              //end user duration Chooser, rest of code at top of file
              timeChooser();
            }
            if (displayTimeG === true) {
              generateTimesOnly(dates[i].times, calendar.querySelector(dateId));
            }
            if (selectRange === true && calendar.querySelector(dateId) !== null && calendar.querySelector(dateId).classList.contains(
              'filler') === false) {
              //use preloaded dates directly blocked.push(preloadedDates[i].day);
              calendar.querySelector(dateId).style.backgroundColor = '#333';
              calendar.querySelector(dateId).classList.add('blocked');
              calendar.querySelector(dateId).title = 'No availability on this day';
              var soldOut = document.createElement('p');
              soldOut.classList.add('calendarTime');
              soldOut.textContent = 'Sold out';
              calendar.querySelector(dateId).appendChild(soldOut);
            }
          }
        }
      } else {
        return;
      }
    }
*/
    if (numberOfMonthsToDisplay === undefined) {
      numberOfMonthsToDisplay = 4;
    }

    
    if (backend === true) {
      var dayblock = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      var dayblockrow = document.createElement('div');
      dayblockrow.classList.add('dayblockrow');
      var title = document.createElement('h4');
      title.textContent = 'Select days of week to block:';
      dayblockrow.appendChild(title);
      dayblock.forEach(function(e, i) {
        var input = document.createElement('input');
        input.setAttribute('type', 'checkbox');
        input.classList.add('block');
        input.name = e;
        input.dataset.block = dayblock.indexOf(e);
        dayblockrow.appendChild(input);
        var label = document.createElement('label');
        label.for = e;
        label.textContent = e;
        dayblockrow.appendChild(label);
      });
      calendar.appendChild(dayblockrow);
      //FUNCTION FOR BLOCKING ALL DAYS OF A TYPE:
      if (backend) {
        var daysToBlock = document.getElementsByClassName('block');
        for (i = 0; i < daysToBlock.length; i++) {
          daysToBlock[i].addEventListener('click', function(e) {
            var blockTheseDays = document.querySelectorAll("[data-dayofweek='" + e.target.dataset.block + "']");
            if (e.target.checked) {
              for (i = 0; i < blockTheseDays.length; i++) {
                blockTheseDays[i].classList.add('widthShape', 'filler');
              }
            } else {
              for (i = 0; i < blockTheseDays.length; i++) {
                blockTheseDays[i].classList.remove('filler');
              }
            }
          });
        }
      }
    }


    return this;
  };
}



















 dynamicData = {
    datesSelectedArray: [],
    datesSelectedArrayObjects: [],
    disabled: false
  };
  calendar = document.createElement('div');
  lastDateClicked = {};
  config = {};
  calendarConfig (parentDiv, preloadedDates, numberOfMonthsToDisplay, displayTimeChooserModal, endUser, endUserDurationChoice, backend, displayBlocked, datesOpen) {
    
    config.preloadedDates = preloadedDates || [];
    config.numberOfMonthsToDisplay = numberOfMonthsToDisplay || 12;
    config.displayTimeChooserModal = displayTimeChooserModal || true;
    config.endUser = endUser || false;
    config.endUserDurationChoice = endUserDurationChoice || false;
    config.backend = backend || false;
    config.displayBlocked = displayBlocked || false;
    config.datesOpen = datesOpen || false;
    config.singleDateChoice = false;
    config.selectRange = !config.singleDateChoice;
    config.language = 'ptPt';
    return config;
  }